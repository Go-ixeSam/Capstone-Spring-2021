{"ast":null,"code":"/* -*- Mode: js; js-indent-level: 2; -*- */\n\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\n\nvar util = require('./util'); // Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\n\n\nvar REGEX_NEWLINE = /(\\r?\\n)/; // Newline character code for charCodeAt() comparisons\n\nvar NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\n\nvar isSourceNode = \"$$$isSourceNode$$$\";\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\n\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\n  this.children = [];\n  this.sourceContents = {};\n  this.line = aLine == null ? null : aLine;\n  this.column = aColumn == null ? null : aColumn;\n  this.source = aSource == null ? null : aSource;\n  this.name = aName == null ? null : aName;\n  this[isSourceNode] = true;\n  if (aChunks != null) this.add(aChunks);\n}\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\n\n\nSourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\n  // The SourceNode we want to fill with the generated code\n  // and the SourceMap\n  var node = new SourceNode(); // All even indices of this array are one line of the generated code,\n  // while all odd indices are the newlines between two adjacent lines\n  // (since `REGEX_NEWLINE` captures its match).\n  // Processed fragments are accessed by calling `shiftNextLine`.\n\n  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n  var remainingLinesIndex = 0;\n\n  var shiftNextLine = function () {\n    var lineContents = getNextLine(); // The last line of a file might not have a newline.\n\n    var newLine = getNextLine() || \"\";\n    return lineContents + newLine;\n\n    function getNextLine() {\n      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;\n    }\n  }; // We need to remember the position of \"remainingLines\"\n\n\n  var lastGeneratedLine = 1,\n      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.\n  // To extract it current and last mapping is used.\n  // Here we store the last mapping.\n\n  var lastMapping = null;\n  aSourceMapConsumer.eachMapping(function (mapping) {\n    if (lastMapping !== null) {\n      // We add the code from \"lastMapping\" to \"mapping\":\n      // First check if there is a new line in between.\n      if (lastGeneratedLine < mapping.generatedLine) {\n        // Associate first line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n        lastGeneratedLine++;\n        lastGeneratedColumn = 0; // The remaining code is added without mapping\n      } else {\n        // There is no new line in between.\n        // Associate the code between \"lastGeneratedColumn\" and\n        // \"mapping.generatedColumn\" with \"lastMapping\"\n        var nextLine = remainingLines[remainingLinesIndex] || '';\n        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);\n        lastGeneratedColumn = mapping.generatedColumn;\n        addMappingWithCode(lastMapping, code); // No more remaining code, continue\n\n        lastMapping = mapping;\n        return;\n      }\n    } // We add the generated code until the first mapping\n    // to the SourceNode without any mapping.\n    // Each line is added as separate string.\n\n\n    while (lastGeneratedLine < mapping.generatedLine) {\n      node.add(shiftNextLine());\n      lastGeneratedLine++;\n    }\n\n    if (lastGeneratedColumn < mapping.generatedColumn) {\n      var nextLine = remainingLines[remainingLinesIndex] || '';\n      node.add(nextLine.substr(0, mapping.generatedColumn));\n      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\n      lastGeneratedColumn = mapping.generatedColumn;\n    }\n\n    lastMapping = mapping;\n  }, this); // We have processed all mappings.\n\n  if (remainingLinesIndex < remainingLines.length) {\n    if (lastMapping) {\n      // Associate the remaining code in the current line with \"lastMapping\"\n      addMappingWithCode(lastMapping, shiftNextLine());\n    } // and add the remaining lines without any mapping\n\n\n    node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n  } // Copy sourcesContent into SourceNode\n\n\n  aSourceMapConsumer.sources.forEach(function (sourceFile) {\n    var content = aSourceMapConsumer.sourceContentFor(sourceFile);\n\n    if (content != null) {\n      if (aRelativePath != null) {\n        sourceFile = util.join(aRelativePath, sourceFile);\n      }\n\n      node.setSourceContent(sourceFile, content);\n    }\n  });\n  return node;\n\n  function addMappingWithCode(mapping, code) {\n    if (mapping === null || mapping.source === undefined) {\n      node.add(code);\n    } else {\n      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;\n      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));\n    }\n  }\n};\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\n\n\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\n  if (Array.isArray(aChunk)) {\n    aChunk.forEach(function (chunk) {\n      this.add(chunk);\n    }, this);\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    if (aChunk) {\n      this.children.push(aChunk);\n    }\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\n\n\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\n  if (Array.isArray(aChunk)) {\n    for (var i = aChunk.length - 1; i >= 0; i--) {\n      this.prepend(aChunk[i]);\n    }\n  } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n    this.children.unshift(aChunk);\n  } else {\n    throw new TypeError(\"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk);\n  }\n\n  return this;\n};\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\n\n\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\n  var chunk;\n\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    chunk = this.children[i];\n\n    if (chunk[isSourceNode]) {\n      chunk.walk(aFn);\n    } else {\n      if (chunk !== '') {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name\n        });\n      }\n    }\n  }\n};\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\n\n\nSourceNode.prototype.join = function SourceNode_join(aSep) {\n  var newChildren;\n  var i;\n  var len = this.children.length;\n\n  if (len > 0) {\n    newChildren = [];\n\n    for (i = 0; i < len - 1; i++) {\n      newChildren.push(this.children[i]);\n      newChildren.push(aSep);\n    }\n\n    newChildren.push(this.children[i]);\n    this.children = newChildren;\n  }\n\n  return this;\n};\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\n\n\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\n  var lastChild = this.children[this.children.length - 1];\n\n  if (lastChild[isSourceNode]) {\n    lastChild.replaceRight(aPattern, aReplacement);\n  } else if (typeof lastChild === 'string') {\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\n  } else {\n    this.children.push(''.replace(aPattern, aReplacement));\n  }\n\n  return this;\n};\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\n\n\nSourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\n  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n};\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\n\n\nSourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {\n  for (var i = 0, len = this.children.length; i < len; i++) {\n    if (this.children[i][isSourceNode]) {\n      this.children[i].walkSourceContents(aFn);\n    }\n  }\n\n  var sources = Object.keys(this.sourceContents);\n\n  for (var i = 0, len = sources.length; i < len; i++) {\n    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n  }\n};\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\n\n\nSourceNode.prototype.toString = function SourceNode_toString() {\n  var str = \"\";\n  this.walk(function (chunk) {\n    str += chunk;\n  });\n  return str;\n};\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\n\n\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\n  var generated = {\n    code: \"\",\n    line: 1,\n    column: 0\n  };\n  var map = new SourceMapGenerator(aArgs);\n  var sourceMappingActive = false;\n  var lastOriginalSource = null;\n  var lastOriginalLine = null;\n  var lastOriginalColumn = null;\n  var lastOriginalName = null;\n  this.walk(function (chunk, original) {\n    generated.code += chunk;\n\n    if (original.source !== null && original.line !== null && original.column !== null) {\n      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {\n        map.addMapping({\n          source: original.source,\n          original: {\n            line: original.line,\n            column: original.column\n          },\n          generated: {\n            line: generated.line,\n            column: generated.column\n          },\n          name: original.name\n        });\n      }\n\n      lastOriginalSource = original.source;\n      lastOriginalLine = original.line;\n      lastOriginalColumn = original.column;\n      lastOriginalName = original.name;\n      sourceMappingActive = true;\n    } else if (sourceMappingActive) {\n      map.addMapping({\n        generated: {\n          line: generated.line,\n          column: generated.column\n        }\n      });\n      lastOriginalSource = null;\n      sourceMappingActive = false;\n    }\n\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n        generated.line++;\n        generated.column = 0; // Mappings end at eol\n\n        if (idx + 1 === length) {\n          lastOriginalSource = null;\n          sourceMappingActive = false;\n        } else if (sourceMappingActive) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column\n            },\n            name: original.name\n          });\n        }\n      } else {\n        generated.column++;\n      }\n    }\n  });\n  this.walkSourceContents(function (sourceFile, sourceContent) {\n    map.setSourceContent(sourceFile, sourceContent);\n  });\n  return {\n    code: generated.code,\n    map: map\n  };\n};\n\nexports.SourceNode = SourceNode;","map":{"version":3,"sources":["C:/Users/Sam/Documents/GitHub/Capstone-Spring-2021/node_modules/source-map-support/node_modules/source-map/lib/source-node.js"],"names":["SourceMapGenerator","require","util","REGEX_NEWLINE","NEWLINE_CODE","isSourceNode","SourceNode","aLine","aColumn","aSource","aChunks","aName","children","sourceContents","line","column","source","name","add","fromStringWithSourceMap","SourceNode_fromStringWithSourceMap","aGeneratedCode","aSourceMapConsumer","aRelativePath","node","remainingLines","split","remainingLinesIndex","shiftNextLine","lineContents","getNextLine","newLine","length","undefined","lastGeneratedLine","lastGeneratedColumn","lastMapping","eachMapping","mapping","generatedLine","addMappingWithCode","nextLine","code","substr","generatedColumn","splice","join","sources","forEach","sourceFile","content","sourceContentFor","setSourceContent","originalLine","originalColumn","prototype","SourceNode_add","aChunk","Array","isArray","chunk","push","TypeError","prepend","SourceNode_prepend","i","unshift","walk","SourceNode_walk","aFn","len","SourceNode_join","aSep","newChildren","replaceRight","SourceNode_replaceRight","aPattern","aReplacement","lastChild","replace","SourceNode_setSourceContent","aSourceFile","aSourceContent","toSetString","walkSourceContents","SourceNode_walkSourceContents","Object","keys","fromSetString","toString","SourceNode_toString","str","toStringWithSourceMap","SourceNode_toStringWithSourceMap","aArgs","generated","map","sourceMappingActive","lastOriginalSource","lastOriginalLine","lastOriginalColumn","lastOriginalName","original","addMapping","idx","charCodeAt","sourceContent","exports"],"mappings":"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","sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\r\n/*\r\n * Copyright 2011 Mozilla Foundation and contributors\r\n * Licensed under the New BSD license. See LICENSE or:\r\n * http://opensource.org/licenses/BSD-3-Clause\r\n */\r\n\r\nvar SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;\r\nvar util = require('./util');\r\n\r\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\r\n// operating systems these days (capturing the result).\r\nvar REGEX_NEWLINE = /(\\r?\\n)/;\r\n\r\n// Newline character code for charCodeAt() comparisons\r\nvar NEWLINE_CODE = 10;\r\n\r\n// Private symbol for identifying `SourceNode`s when multiple versions of\r\n// the source-map library are loaded. This MUST NOT CHANGE across\r\n// versions!\r\nvar isSourceNode = \"$$$isSourceNode$$$\";\r\n\r\n/**\r\n * SourceNodes provide a way to abstract over interpolating/concatenating\r\n * snippets of generated JavaScript source code while maintaining the line and\r\n * column information associated with the original source code.\r\n *\r\n * @param aLine The original line number.\r\n * @param aColumn The original column number.\r\n * @param aSource The original source's filename.\r\n * @param aChunks Optional. An array of strings which are snippets of\r\n *        generated JS, or other SourceNodes.\r\n * @param aName The original identifier.\r\n */\r\nfunction SourceNode(aLine, aColumn, aSource, aChunks, aName) {\r\n  this.children = [];\r\n  this.sourceContents = {};\r\n  this.line = aLine == null ? null : aLine;\r\n  this.column = aColumn == null ? null : aColumn;\r\n  this.source = aSource == null ? null : aSource;\r\n  this.name = aName == null ? null : aName;\r\n  this[isSourceNode] = true;\r\n  if (aChunks != null) this.add(aChunks);\r\n}\r\n\r\n/**\r\n * Creates a SourceNode from generated code and a SourceMapConsumer.\r\n *\r\n * @param aGeneratedCode The generated code\r\n * @param aSourceMapConsumer The SourceMap for the generated code\r\n * @param aRelativePath Optional. The path that relative sources in the\r\n *        SourceMapConsumer should be relative to.\r\n */\r\nSourceNode.fromStringWithSourceMap =\r\n  function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {\r\n    // The SourceNode we want to fill with the generated code\r\n    // and the SourceMap\r\n    var node = new SourceNode();\r\n\r\n    // All even indices of this array are one line of the generated code,\r\n    // while all odd indices are the newlines between two adjacent lines\r\n    // (since `REGEX_NEWLINE` captures its match).\r\n    // Processed fragments are accessed by calling `shiftNextLine`.\r\n    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\r\n    var remainingLinesIndex = 0;\r\n    var shiftNextLine = function() {\r\n      var lineContents = getNextLine();\r\n      // The last line of a file might not have a newline.\r\n      var newLine = getNextLine() || \"\";\r\n      return lineContents + newLine;\r\n\r\n      function getNextLine() {\r\n        return remainingLinesIndex < remainingLines.length ?\r\n            remainingLines[remainingLinesIndex++] : undefined;\r\n      }\r\n    };\r\n\r\n    // We need to remember the position of \"remainingLines\"\r\n    var lastGeneratedLine = 1, lastGeneratedColumn = 0;\r\n\r\n    // The generate SourceNodes we need a code range.\r\n    // To extract it current and last mapping is used.\r\n    // Here we store the last mapping.\r\n    var lastMapping = null;\r\n\r\n    aSourceMapConsumer.eachMapping(function (mapping) {\r\n      if (lastMapping !== null) {\r\n        // We add the code from \"lastMapping\" to \"mapping\":\r\n        // First check if there is a new line in between.\r\n        if (lastGeneratedLine < mapping.generatedLine) {\r\n          // Associate first line with \"lastMapping\"\r\n          addMappingWithCode(lastMapping, shiftNextLine());\r\n          lastGeneratedLine++;\r\n          lastGeneratedColumn = 0;\r\n          // The remaining code is added without mapping\r\n        } else {\r\n          // There is no new line in between.\r\n          // Associate the code between \"lastGeneratedColumn\" and\r\n          // \"mapping.generatedColumn\" with \"lastMapping\"\r\n          var nextLine = remainingLines[remainingLinesIndex] || '';\r\n          var code = nextLine.substr(0, mapping.generatedColumn -\r\n                                        lastGeneratedColumn);\r\n          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn -\r\n                                              lastGeneratedColumn);\r\n          lastGeneratedColumn = mapping.generatedColumn;\r\n          addMappingWithCode(lastMapping, code);\r\n          // No more remaining code, continue\r\n          lastMapping = mapping;\r\n          return;\r\n        }\r\n      }\r\n      // We add the generated code until the first mapping\r\n      // to the SourceNode without any mapping.\r\n      // Each line is added as separate string.\r\n      while (lastGeneratedLine < mapping.generatedLine) {\r\n        node.add(shiftNextLine());\r\n        lastGeneratedLine++;\r\n      }\r\n      if (lastGeneratedColumn < mapping.generatedColumn) {\r\n        var nextLine = remainingLines[remainingLinesIndex] || '';\r\n        node.add(nextLine.substr(0, mapping.generatedColumn));\r\n        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);\r\n        lastGeneratedColumn = mapping.generatedColumn;\r\n      }\r\n      lastMapping = mapping;\r\n    }, this);\r\n    // We have processed all mappings.\r\n    if (remainingLinesIndex < remainingLines.length) {\r\n      if (lastMapping) {\r\n        // Associate the remaining code in the current line with \"lastMapping\"\r\n        addMappingWithCode(lastMapping, shiftNextLine());\r\n      }\r\n      // and add the remaining lines without any mapping\r\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\r\n    }\r\n\r\n    // Copy sourcesContent into SourceNode\r\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\r\n      var content = aSourceMapConsumer.sourceContentFor(sourceFile);\r\n      if (content != null) {\r\n        if (aRelativePath != null) {\r\n          sourceFile = util.join(aRelativePath, sourceFile);\r\n        }\r\n        node.setSourceContent(sourceFile, content);\r\n      }\r\n    });\r\n\r\n    return node;\r\n\r\n    function addMappingWithCode(mapping, code) {\r\n      if (mapping === null || mapping.source === undefined) {\r\n        node.add(code);\r\n      } else {\r\n        var source = aRelativePath\r\n          ? util.join(aRelativePath, mapping.source)\r\n          : mapping.source;\r\n        node.add(new SourceNode(mapping.originalLine,\r\n                                mapping.originalColumn,\r\n                                source,\r\n                                code,\r\n                                mapping.name));\r\n      }\r\n    }\r\n  };\r\n\r\n/**\r\n * Add a chunk of generated JS to this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.add = function SourceNode_add(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    aChunk.forEach(function (chunk) {\r\n      this.add(chunk);\r\n    }, this);\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    if (aChunk) {\r\n      this.children.push(aChunk);\r\n    }\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Add a chunk of generated JS to the beginning of this source node.\r\n *\r\n * @param aChunk A string snippet of generated JS code, another instance of\r\n *        SourceNode, or an array where each member is one of those things.\r\n */\r\nSourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {\r\n  if (Array.isArray(aChunk)) {\r\n    for (var i = aChunk.length-1; i >= 0; i--) {\r\n      this.prepend(aChunk[i]);\r\n    }\r\n  }\r\n  else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\r\n    this.children.unshift(aChunk);\r\n  }\r\n  else {\r\n    throw new TypeError(\r\n      \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" + aChunk\r\n    );\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Walk over the tree of JS snippets in this node and its children. The\r\n * walking function is called once for each snippet of JS and is passed that\r\n * snippet and the its original associated source's line/column location.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walk = function SourceNode_walk(aFn) {\r\n  var chunk;\r\n  for (var i = 0, len = this.children.length; i < len; i++) {\r\n    chunk = this.children[i];\r\n    if (chunk[isSourceNode]) {\r\n      chunk.walk(aFn);\r\n    }\r\n    else {\r\n      if (chunk !== '') {\r\n        aFn(chunk, { source: this.source,\r\n                     line: this.line,\r\n                     column: this.column,\r\n                     name: this.name });\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\r\n * each of `this.children`.\r\n *\r\n * @param aSep The separator.\r\n */\r\nSourceNode.prototype.join = function SourceNode_join(aSep) {\r\n  var newChildren;\r\n  var i;\r\n  var len = this.children.length;\r\n  if (len > 0) {\r\n    newChildren = [];\r\n    for (i = 0; i < len-1; i++) {\r\n      newChildren.push(this.children[i]);\r\n      newChildren.push(aSep);\r\n    }\r\n    newChildren.push(this.children[i]);\r\n    this.children = newChildren;\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Call String.prototype.replace on the very right-most source snippet. Useful\r\n * for trimming whitespace from the end of a source node, etc.\r\n *\r\n * @param aPattern The pattern to replace.\r\n * @param aReplacement The thing to replace the pattern with.\r\n */\r\nSourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {\r\n  var lastChild = this.children[this.children.length - 1];\r\n  if (lastChild[isSourceNode]) {\r\n    lastChild.replaceRight(aPattern, aReplacement);\r\n  }\r\n  else if (typeof lastChild === 'string') {\r\n    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);\r\n  }\r\n  else {\r\n    this.children.push(''.replace(aPattern, aReplacement));\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Set the source content for a source file. This will be added to the SourceMapGenerator\r\n * in the sourcesContent field.\r\n *\r\n * @param aSourceFile The filename of the source file\r\n * @param aSourceContent The content of the source file\r\n */\r\nSourceNode.prototype.setSourceContent =\r\n  function SourceNode_setSourceContent(aSourceFile, aSourceContent) {\r\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\r\n  };\r\n\r\n/**\r\n * Walk over the tree of SourceNodes. The walking function is called for each\r\n * source file content and is passed the filename and source content.\r\n *\r\n * @param aFn The traversal function.\r\n */\r\nSourceNode.prototype.walkSourceContents =\r\n  function SourceNode_walkSourceContents(aFn) {\r\n    for (var i = 0, len = this.children.length; i < len; i++) {\r\n      if (this.children[i][isSourceNode]) {\r\n        this.children[i].walkSourceContents(aFn);\r\n      }\r\n    }\r\n\r\n    var sources = Object.keys(this.sourceContents);\r\n    for (var i = 0, len = sources.length; i < len; i++) {\r\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\r\n    }\r\n  };\r\n\r\n/**\r\n * Return the string representation of this source node. Walks over the tree\r\n * and concatenates all the various snippets together to one string.\r\n */\r\nSourceNode.prototype.toString = function SourceNode_toString() {\r\n  var str = \"\";\r\n  this.walk(function (chunk) {\r\n    str += chunk;\r\n  });\r\n  return str;\r\n};\r\n\r\n/**\r\n * Returns the string representation of this source node along with a source\r\n * map.\r\n */\r\nSourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {\r\n  var generated = {\r\n    code: \"\",\r\n    line: 1,\r\n    column: 0\r\n  };\r\n  var map = new SourceMapGenerator(aArgs);\r\n  var sourceMappingActive = false;\r\n  var lastOriginalSource = null;\r\n  var lastOriginalLine = null;\r\n  var lastOriginalColumn = null;\r\n  var lastOriginalName = null;\r\n  this.walk(function (chunk, original) {\r\n    generated.code += chunk;\r\n    if (original.source !== null\r\n        && original.line !== null\r\n        && original.column !== null) {\r\n      if(lastOriginalSource !== original.source\r\n         || lastOriginalLine !== original.line\r\n         || lastOriginalColumn !== original.column\r\n         || lastOriginalName !== original.name) {\r\n        map.addMapping({\r\n          source: original.source,\r\n          original: {\r\n            line: original.line,\r\n            column: original.column\r\n          },\r\n          generated: {\r\n            line: generated.line,\r\n            column: generated.column\r\n          },\r\n          name: original.name\r\n        });\r\n      }\r\n      lastOriginalSource = original.source;\r\n      lastOriginalLine = original.line;\r\n      lastOriginalColumn = original.column;\r\n      lastOriginalName = original.name;\r\n      sourceMappingActive = true;\r\n    } else if (sourceMappingActive) {\r\n      map.addMapping({\r\n        generated: {\r\n          line: generated.line,\r\n          column: generated.column\r\n        }\r\n      });\r\n      lastOriginalSource = null;\r\n      sourceMappingActive = false;\r\n    }\r\n    for (var idx = 0, length = chunk.length; idx < length; idx++) {\r\n      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\r\n        generated.line++;\r\n        generated.column = 0;\r\n        // Mappings end at eol\r\n        if (idx + 1 === length) {\r\n          lastOriginalSource = null;\r\n          sourceMappingActive = false;\r\n        } else if (sourceMappingActive) {\r\n          map.addMapping({\r\n            source: original.source,\r\n            original: {\r\n              line: original.line,\r\n              column: original.column\r\n            },\r\n            generated: {\r\n              line: generated.line,\r\n              column: generated.column\r\n            },\r\n            name: original.name\r\n          });\r\n        }\r\n      } else {\r\n        generated.column++;\r\n      }\r\n    }\r\n  });\r\n  this.walkSourceContents(function (sourceFile, sourceContent) {\r\n    map.setSourceContent(sourceFile, sourceContent);\r\n  });\r\n\r\n  return { code: generated.code, map: map };\r\n};\r\n\r\nexports.SourceNode = SourceNode;\r\n"]},"metadata":{},"sourceType":"script"}